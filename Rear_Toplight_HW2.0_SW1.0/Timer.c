#include "Timer.h"

/*
 * define
 */
uint32_t count = 0u,H_Level_C = 0u,H_Level_T = 0u,L_Level_C = 0u,L_Level_T = 0u;
static volatile uint32_t sys_LED_Time = 0u;
uint8_t flag = 2u,Pwm_duty = 0u;

/****************************************************************************************
 * 函数名     ：Timer0_Init
 * 函数功能：8位定时器0初始化,每64us计时加1，32*256=8192us
 * 入口参数：无
 * 返回          ：无
****************************************************************************************/
#if Timer0
void Timer0_Init(void)
{
	/********************************
	WDTPS<3:0>:看门狗定时器预分频比选择位
		0000 = 1：32
		0001 = 1：64
		0010 = 1：128
		0011 = 1：256
		0100 = 1：512（默认） 16ms
		0101 = 1：1024    32ms
		0110 = 1：2048	64ms
		0111 = 1：4096   128ms
		1000 = 1：8192
		1001 = 1：16384
		1010 = 1：32768
		1011 = 1：65536
		11xx = 保留
	**********************************/
	WDTPS = 0x07;

	_CWDT();

	// 0xC1 1100 0100
	// bit7 1 = 禁止所有IO端口上拉功能
	// bit6 1 = INT0/P0.2 为上升沿触发
	// 		0 = INT0/P0.2 为下降沿触发
	// bit5 1 = 计数模式，T0 的时钟为外部时钟T0CK/P0.2
	//      0 = 定时模式，T0 的时钟为机器时钟SCLK/4
	// bit4 T0 计数脉冲信号边沿选择位
	// bit3 PSA 预分频器分配控制位
	//      1 = 预分频器用于WDT
	//	    0 = 预分频器用于T0
	// bit2-0
	//	PS<2:0>    WDT分频比 T0分频比
	//		000 	1 : 1 	1 : 2		0.0000005s*255=0.0001275s
	//		001 	1 : 2 	1 : 4    	0.000001s*255=0.00255s
	//		010 	1 : 4 	1 : 8		0.000002s*255=0.00510s
	//		011 	1 : 8 	1 : 16		0.000004s*255=0.00102s
	//		100 	1 : 16 	1 : 32		0.000008s*255=0.00204s  √
	//		101 	1 : 32 	1 : 64   	0.000016s*255=0.00408s
	//		110 	1 : 64 	1 : 128    	0.000032s*255=0.00816s
	//		111 	1 : 128 1 : 256		0.000064s*255=0.01632s

	OPTR = 0xC4;	// INT0/P0.2 为上升沿触发
	_CWDT();
	T0 = 1;  //8 位计数器
	T0IE = 1;  //暂不使能//使能T0中断
	T0IF = 0;  //清除标记位
	PT0 = 1;   //高优先级
	//AIE = 1;  //全局中断开启
}
#endif

/****************************************************************************************
 * 函数名     ：Timer1_Init
 * 函数功能：16位定时器1初始化,使用PP2 PP1，重载计数，每2us计时加1 2*50000=100ms 2KHz
 * 入口参数：无
 * 返回          ：无
****************************************************************************************/
#if Timer1
void Timer1_Init(void)
{
    /*
     *  0x1 111 0000
		OSCCTL<6:4>
		111=1:1（选择内部高频时钟为16MHz）
		110=1:2（选择内部高频时钟为8MHz）
		101=1:4（选择内部高频时钟为4MHz）
		100=1:8（选择内部高频时钟为2MHz）
		011=1:16（选择内部高频时钟为1MHz）
		010=1:32（默认，选择内部高频时钟为500kHz）
		001=1:64（选择内部高频时钟为250kHz）
		000=1:256（选择内部高频时钟为62.5kHz）
	     */
	//OSCCTL = 0x30;
	PWMS = 0; //PWM1 分配到P0.2 口，PWM2 分配到P1.0 口
	//TR02 = 1; //将TR00 或TR01 置1，禁止引脚PWM1 /PWM2 的输出驱动器
	//TR10 = 1;
	PP2=249;		//50000
	PP1=249;
	PWM1L = 0;
	PWM2L = 0;

	//2K Hz PWM

	T1CS = 0; //当前定时模式*计数模式
	T1OSCEN = 0; //计数模式 当T1OSCEN=0 时T1 时钟为T1CK
	T1CLKEN = 0; //当T1CLKEN=1 时T1 时钟为内部高频振荡器时钟
			     //当T1CLKEN=0 时T1 时钟为机器时钟SCLK/4
	//T1CTL = 0xB1;	//使能重载，开启T1	16M/4/8
	/*  T1CKS<1:0>
	 	11 = 1/8 倍预分频比
		10 = 1/4 倍预分频比
		01 = 1/2 倍预分频比
		00 = 1/1 倍预分频比
	 */
	T1CKS1 = 1;  //8分频
	T1CKS0 = 1;
	T1H=0;  //将T1L/H 清零
	T1L=0;
	//T1IE=1;
	//PWM2IE = 1;
	//PWM2IF = 0;
	//T1IF=0;
	T1ON = 1;  //启动T1

	PWM1ON = 1;
	PWM2ON = 1;

	TR02 = 0; //将TR00 或TR01 清零使能引脚PWM1 /PWM2 的输出驱动
	TR10 = 0;

//	PUIE = 1;
//	AIE  = 1;
}
#endif

/****************************************************************************************
 * 函数名     ：Timer4_Init
 * 函数功能：16位定时器2初始化,使用T4REH,T4REL，每1us计时加1
 * 入口参数：无
 * 返回          ：无
****************************************************************************************/
#if Timer4
void Timer4_Init(void)
{
	//0x0001 0001
	//2分频
	T4CTL = 0x11;	//禁止重载 16MHz时钟 2分频  周期0.000 000 125s
	T4H=0;
	T4L=0;
	//T4REH=0x00;		//8   1us
	//T4REL=0x08;
	//T4IF=0;
	T4IE=1;
	//PUIE = 1;
	//AIE  = 1;
}
#endif

//PWM duty set function
void set_PWM1L(uint8_t duty)
{
	PWM1L = 249 * duty * 0.01;
}

void set_PWM2L(uint8_t duty)
{
	PWM2L = 249 * duty * 0.01;
}

//Init timer
void timer_init(void)
{
	Timer1_Init(); //Timer1 CPP1 CPP2 PWM 初始化
	Timer0_Init(); //Timer0 PWM计数定时器
}

//P0引脚电平变化中断初始化
void P0_INT_init(void)
{
//	TR05 = 1; //P05设为输入
//	IOCL5 = 1; //IOCL5 P05口 使能引脚变化中断

	P0IE = 1;
	PP0 = 1; //高优先级
	P0IF = 0;
	//PUIE = 1;
	//AIE = 1;
}

//获取占空比
uint8_t get_pwmduty(void)
{
	pwm_deal();
	return Pwm_duty;
}

void pwm_deal(void)
{

	if(count > 10)  //超时
	{
		if(P05)
			Pwm_duty = 0;
		else
			Pwm_duty = 100;
	}
	else
	{
		//L_Level 周期
		//H_Level 高电平
		Pwm_duty =  ((H_Level_C * 255 + H_Level_T) * 100) / (L_Level_C * 255 + L_Level_T);
	}
//	UART_SendBuf('D');
//	UART_SendBuf(':');
//	USART_Send_num(Pwm_duty);

	//Pwm_duty =  ((H_Level_C * 255 + H_Level_T) * 100) / (L_Level_C * 255 + L_Level_T);

}

uint32_t Clock_GetSysLEDTimeStatus(void)
{
    return sys_LED_Time;  //
}

void Clock_ClearSysLEDTimeStatus(void)
{
	sys_LED_Time = 0;
}


//;***********************************************************************************
//;* 函 数 名:  INT_FUN() __interrupt
//;* 函数功能: 中断函数
//;* 入口参数: 无
//;* 返    回:   无
//;************************************************************************************
void int_fun0() __interrupt (0)
{
	/* 请勿更改此处 T3处理代码 */
	if(T3IF)
	{
		T3IF = 0;
		Touch_Int_Flg = 1;
	}

	if(T0IF)   //T0中断
	{
		T0IF = 0;
		count++;
		sys_LED_Time++;
		_CWDT();
	}

	if(P0IF)  //P0电平变化中断
	{
		LOCKP0();	//锁存P0口的状态
		P0IF=0; //清零中断标志量

		if(flag == 1)	//已获取高电平
		{
			flag = 2; //2表示获取到下降沿，记录高电平值
			H_Level_C = count;  //定时器圈数
			H_Level_T = T0;		//T0当前值
		}

		if(!P05)  //根据电路 输入高电平时 读为电平
		{
			if(flag == 0)   //初始等待状态
			{
				flag = 1; //1表示初次获取到上升沿，初始化
				T0 = 0;	//清零计数
				count = 0;
			}
			else
				if(flag == 2)   //第二次获取上升沿 一个周期
				{
					L_Level_C = count;  //定时器圈数
					L_Level_T = T0;		//T0当前值

					flag = 1;       //标记下一个周期捕获到上升沿
					T0 = 0;	//清零计数
					count = 0;
				}
		}
	}
}

void int_fun1() __interrupt (1)
{


}

